<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_snc_jwt_lib.core</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>Core JWT code</description>
        <name>core</name>
        <script><![CDATA[var core = Class.create();
core.prototype = {
	HEADER: {
		"alg": "HS256",
		"typ": "JWT"
	},
	PAYLOAD: {
	},
	DEFAULT_EXPIRY_SECONDS: 60,
	SECRET : '',
	// maps JWT algorithm IDs to internal algorithms used by CertificateEncryption().generateMac()
	ALG_MAP: { 
		'HS256': 'HmacSHA256',
	},
	// Key of the algorithm passed to CertificateEncryption().generateMac()
	ALGORITHM : 'HmacSHA256',
	// Example message (for testing purposes)
	EXAMPLE_MESSAGE: '',
	// List of registered claims (for lookup/reference)
	REG_CLAIMS: {
		'sub': 'sub', //subject
		'aud': 'aud', //audience
		'exp': 'exp', //expiry
		'iss': 'iss', //issuer
		'iat': 'iat', //issued at
	},
	/* And we're off! */
	initialize: function(Algorithm) {
		Algorithm = Algorithm || 'HS256'; // default is HmacSHA256
		if( this.ALG_MAP.hasOwnProperty(Algorithm) ){
			// Good algorithm
			this.ALGORITHM = this.ALG_MAP[Algorithm]; 
			this.HEADER.alg = Algorithm;
		} else {
			// Algorithm not known or supported 
			throw new Exception('Error, specified algorithm ' + Algorithm + ' is not currently supported. Supported algorithms: ' + Object.keys(this.ALG_MAP).join(','));
		}
	},
	// Set the payload; allow only registered claims, see RFC7519
	setPayload: function( obj ){
		var reg = ['iss','sub','aud','exp','nbf','iat','jti'];
		for( var k in obj ){
			if( obj.hasOwnProperty(k) && reg.indexOf(k) !== -1 )
				this.PAYLOAD[k] = obj[k];
		}
	},
	// Accepts an arbitrary object as the payload, 
	// instead of sticking to registered claims
	setRawPayload: function( obj ){
		if( typeof obj === "object" )
			this.PAYLOAD = obj;
	},
	// Sets the issuer (iss) field of the payload
	setIssuer: function( iss ){
		iss = iss || '';
		if( iss.length > 0 )
			this.PAYLOAD.iss = iss;
	},
	// Computes and sets the expiration time of the token
	// @param integer Number of seconds the token should be valid
	setLifespan: function( time ){
		time = time || this.DEFAULT_EXPIRY_SECONDS;
		var nowTime = new GlideDateTime().getNumericValue();
//		var expTime = nowTime + (time * 1000);
		var expTime = parseInt((nowTime / 1000) + (time * 1));
		this.PAYLOAD.exp = expTime + "";
	},
	// @param secret The secret used to sign the token
	getToken: function( secret ) {
		secret = secret || null;
		if( ! secret ){
			gs.error("Cannot compute token without a secret, please try again!", 'jwt.getToken()');
			return false;
		} else {
			this.SECRET = secret;
		}
		//** Signing happens below this line **//
		var ce = new CertificateEncryption();
		// payload for signature is: 
		// HmacSHA256( base64UrlEncode(header) + '.' + base64UrlEncode(payload) , secret )
		var payload = this.base64urlencode( JSON.stringify(this.HEADER) ) + '.' + this.base64urlencode( JSON.stringify(this.PAYLOAD) );
		// CertificateEncryption.generateMac expects the secret to be base64 encoded 
		//   (because it decodes it before passing it to the HMAC function internally)
		var signature_enc = ce.generateMac( this.base64urlencode(this.SECRET) , this.ALGORITHM , payload ); // CertificateEncryption
		// construct the final message
		var message_enc = payload + '.' + this.formatSignature(signature_enc);

		/*if( this.isDebug ) {
			gs.info("Payload object: " + JSON.stringify(this.PAYLOAD));
			gs.info("Payload: " + payload);
			gs.info("Signature: " + signature_enc);
			gs.info("Message: " + message_enc);
			/*		gs.info("Example: " + this.EXAMPLE_MESSAGE + "\n");
		gs.info("Matches example message? " + (this.EXAMPLE_MESSAGE == message_enc));
		}*/
		return message_enc;
	},
	unformatSignature: function(s){
		//
		s = s.replace(/-/g, '+'); // 62nd char of encoding
		s = s.replace(/_/g, '/'); // 63rd char of encoding
		switch (s.length % 4) // Pad with trailing '='s
		{
			case 0: break; // No pad chars in this case
			case 2: s += "=="; break; // Two pad chars
			case 3: s += "="; break; // One pad char
			default: throw new InputException("Illegal base64url string!");
		}
		return s;
	},
	formatSignature: function(s){
		s = s.split('=')[0]; // Remove any trailing '='s
		s = s.replace(/\+/g, '-'); // 62nd char of encoding
		s = s.replace(/\//g, '_'); // 63rd char of encoding
		// TODO optimize this; we can do much better
		return s;
	},
	base64urlencode: function (arg)
	{
		var s = gs.base64Encode(arg); // Standard base64 encoder
		s = s.split('=')[0]; // Remove any trailing '='s
		s = s.replace(/\+/g, '-'); // 62nd char of encoding
		s = s.replace(/\//g, '_'); // 63rd char of encoding
		// TODO optimize this; we can do much better
		return s;
	},

	base64urldecode: function(arg)
	{
		var s = arg;
		s = s.replace(/-/g, '+'); // 62nd char of encoding
		s = s.replace(/_/g, '/'); // 63rd char of encoding
		switch (s.length % 4) // Pad with trailing '='s
		{
			case 0: break; // No pad chars in this case
			case 2: s += "=="; break; // Two pad chars
			case 3: s += "="; break; // One pad char
			default: throw new InputException("Illegal base64url string!");
		}
		return gs.base64Decode(s); // Standard base64 decoder
	},
	type: 'core'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>chris.webster</sys_created_by>
        <sys_created_on>2019-06-05 16:32:51</sys_created_on>
        <sys_id>5f17e96adb717b00c24df78eaf961916</sys_id>
        <sys_name>core</sys_name>
        <sys_package display_value="JWT Library" source="x_snc_jwt_lib">3d17a56adb717b00c24df78eaf961906</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="JWT Library">3d17a56adb717b00c24df78eaf961906</sys_scope>
        <sys_update_name>sys_script_include_5f17e96adb717b00c24df78eaf961916</sys_update_name>
    </sys_script_include>
</record_update>
